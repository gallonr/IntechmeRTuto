---
title: "purrr - Programmation fonctionnelle"
subtitle: "Itérations avec la famille map()"
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
    theme: cosmo
    css: ../css/custom.css
runtime: shiny_prerendered
description: "map(), map2(), pmap(), nested data et programmation fonctionnelle"
---

```{r setup, include=FALSE}
library(learnr)
library(tidyverse)
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)

penguins <- palmerpenguins::penguins |> drop_na()
```

```{r logo, echo=FALSE, results='asis'}
htmltools::img(src = "images/logo.png", id = "tutorial-logo", alt = "Logo Cnam-Intechmer")
```

## Bienvenue

**Objectifs :**

- ✅ Comprendre la **programmation fonctionnelle**
- ✅ Utiliser `map()` et ses variantes
- ✅ Travailler avec des **listes**
- ✅ Maîtriser `map2()` et `pmap()`
- ✅ Manipuler des **données imbriquées** (nested data)

**Durée :** 75 minutes

---

## Section 1 : Introduction à map()

### Pourquoi map() ?

Remplace les boucles `for` par du code plus lisible et expressif.

```{r demo-map-vs-for, exercise=TRUE}
# AVEC FOR
resultats_for <- vector("double", 3)
variables <- list(penguins$bill_length_mm, 
                   penguins$bill_depth_mm, 
                   penguins$flipper_length_mm)

for (i in seq_along(variables)) {
  resultats_for[i] <- mean(variables[[i]], na.rm = TRUE)
}
resultats_for

# AVEC MAP
variables |> map_dbl(mean, na.rm = TRUE)
```

### map() - Retourne une liste

```{r demo-map-basic, exercise=TRUE}
# Appliquer une fonction à chaque élément
vecteurs <- list(
  a = 1:5,
  b = 10:15,
  c = 20:25
)

vecteurs |> map(sum)
```

### Exercice 1 : Premier map()

Calculez la longueur de chaque vecteur dans la liste :

```{r ex1-map, exercise=TRUE}
ma_liste <- list(
  x = c(1, 2, 3),
  y = c(10, 20, 30, 40),
  z = c(100, 200)
)

ma_liste |> map(_____)
```

```{r ex1-map-solution}
ma_liste <- list(
  x = c(1, 2, 3),
  y = c(10, 20, 30, 40),
  z = c(100, 200)
)

ma_liste |> map(length)
```

---

## Section 2 : Variantes de map()

### map_dbl(), map_chr(), map_int()

Retournent des vecteurs atomiques au lieu de listes :

```{r demo-map-variants, exercise=TRUE}
colonnes_num <- penguins |> select(where(is.numeric))

# map_dbl : retourne un vecteur numérique
colonnes_num |> map_dbl(mean, na.rm = TRUE)

# map_chr : retourne un vecteur de caractères
colonnes_num |> map_chr(~paste("Moyenne:", round(mean(.x, na.rm = TRUE), 1)))

# map_int : retourne un vecteur d'entiers
list(a = 1:5, b = 1:10, c = 1:3) |> map_int(length)
```

### Syntaxe avec ~

La formule `~` crée une fonction anonyme où `.x` représente l'élément :

```{r demo-map-tilde, exercise=TRUE}
# Ces trois syntaxes sont équivalentes :

# 1. Fonction nommée
penguins |> select(where(is.numeric)) |> map_dbl(mean, na.rm = TRUE)

# 2. Fonction anonyme classique
penguins |> select(where(is.numeric)) |> map_dbl(function(x) mean(x, na.rm = TRUE))

# 3. Formule ~ (raccourci)
penguins |> select(where(is.numeric)) |> map_dbl(~mean(.x, na.rm = TRUE))
```

### Exercice 2 : map_dbl()

Calculez l'écart-type de chaque variable numérique :

```{r ex2-map-dbl, exercise=TRUE}
penguins |>
  select(where(is.numeric)) |>
  map_dbl(~_____)
```

```{r ex2-map-dbl-solution}
penguins |>
  select(where(is.numeric)) |>
  map_dbl(~sd(.x, na.rm = TRUE)) |>
  round(2)
```

---

## Section 3 : map2() - Deux inputs

### Itérer sur deux listes en parallèle

```{r demo-map2, exercise=TRUE}
x <- list(1, 10, 100)
y <- list(2, 20, 200)

# Additionner les éléments correspondants
map2_dbl(x, y, `+`)

# Ou avec une fonction personnalisée
map2_dbl(x, y, ~.x * .y)
```

### Utilisation pratique

```{r demo-map2-practical, exercise=TRUE}
# Créer plusieurs graphiques
especes <- unique(penguins$species)
couleurs <- c("steelblue", "coral", "lightgreen")

graphiques <- map2(especes, couleurs, function(sp, col) {
  penguins |>
    filter(species == sp) |>
    ggplot(aes(x = body_mass_g)) +
    geom_histogram(fill = col, bins = 20) +
    labs(title = paste("Distribution -", sp)) +
    theme_minimal()
})

# Afficher le premier
graphiques[[1]]
```

### Exercice 3 : map2()

Créez des résumés personnalisés pour chaque variable :

```{r ex3-map2, exercise=TRUE}
variables <- list(penguins$bill_length_mm, penguins$body_mass_g)
noms <- c("Longueur bec", "Masse")

map2_chr(variables, noms, ~paste(_____, "- Moyenne:", round(mean(.x, na.rm = TRUE), 1)))
```

```{r ex3-map2-solution}
variables <- list(penguins$bill_length_mm, penguins$body_mass_g)
noms <- c("Longueur bec", "Masse")

map2_chr(variables, noms, 
         ~paste(.y, "- Moyenne:", round(mean(.x, na.rm = TRUE), 1)))
```

---

## Section 4 : pmap() - Multiple inputs

### pmap() avec une liste de listes

```{r demo-pmap, exercise=TRUE}
# Paramètres multiples
params <- list(
  moyenne = c(5, 10, 15),
  ecart_type = c(1, 2, 3),
  n = c(10, 20, 30)
)

# Générer des échantillons aléatoires
echantillons <- pmap(params, rnorm)

echantillons |> map(summary)
```

### Exercice 4 : pmap()

Créez des intervalles avec pmap() :

```{r ex4-pmap, exercise=TRUE}
intervalles <- list(
  debut = c(1, 10, 100),
  fin = c(5, 15, 105),
  pas = c(1, 1, 1)
)

pmap(intervalles, seq)
```

```{r ex4-pmap-solution}
intervalles <- list(
  debut = c(1, 10, 100),
  fin = c(5, 15, 105),
  pas = c(1, 1, 1)
)

# from, to, by dans seq()
resultats <- pmap(intervalles, ~seq(from = ..1, to = ..2, by = ..3))
resultats
```

---

## Section 5 : Nested data (données imbriquées)

### nest() - Créer des données imbriquées

```{r demo-nest, exercise=TRUE}
# Imbriquer les données par espèce
penguins_nested <- penguins |>
  group_by(species) |>
  nest()

penguins_nested

# Voir les données pour Adelie
penguins_nested$data[[1]] |> head()
```

### map() sur des données imbriquées

```{r demo-nest-map, exercise=TRUE}
# Calculer des statistiques pour chaque groupe
penguins_nested <- penguins |>
  group_by(species) |>
  nest() |>
  mutate(
    n_obs = map_int(data, nrow),
    masse_moy = map_dbl(data, ~mean(.x$body_mass_g, na.rm = TRUE))
  )

penguins_nested |> select(-data)
```

### Exercice 5 : Nested data

Calculez la corrélation entre longueur du bec et masse pour chaque espèce :

```{r ex5-nested, exercise=TRUE}
penguins |>
  group_by(species) |>
  nest() |>
  mutate(
    correlation = map_dbl(data, ~cor(.x$_____, .x$_____, use = "complete.obs"))
  ) |>
  select(species, correlation)
```

```{r ex5-nested-solution}
penguins |>
  group_by(species) |>
  nest() |>
  mutate(
    correlation = map_dbl(data, ~cor(.x$bill_length_mm, .x$body_mass_g, 
                                      use = "complete.obs"))
  ) |>
  select(species, correlation) |>
  mutate(correlation = round(correlation, 3))
```

---

## Section 6 : Modèles avec map()

### Ajuster un modèle par groupe

```{r demo-models, exercise=TRUE}
# Régression linéaire pour chaque espèce
models <- penguins |>
  group_by(species) |>
  nest() |>
  mutate(
    model = map(data, ~lm(body_mass_g ~ flipper_length_mm, data = .x)),
    r_squared = map_dbl(model, ~summary(.x)$r.squared)
  )

models |> select(species, r_squared)
```

### Extraire les coefficients

```{r demo-coefficients, exercise=TRUE}
models <- penguins |>
  group_by(species) |>
  nest() |>
  mutate(
    model = map(data, ~lm(body_mass_g ~ flipper_length_mm, data = .x)),
    coefs = map(model, broom::tidy)
  )

# Déimbriquer les coefficients
models |>
  select(species, coefs) |>
  unnest(coefs)
```

### Exercice 6 : Modèles multiples

Ajustez une régression pour chaque île et extrayez le R² :

```{r ex6-models, exercise=TRUE}
penguins |>
  group_by(_____) |>
  nest() |>
  mutate(
    model = map(data, ~lm(_____ ~ _____, data = .x)),
    r2 = map_dbl(model, ~summary(.x)$r.squared)
  ) |>
  select(island, r2)
```

```{r ex6-models-solution}
penguins |>
  group_by(island) |>
  nest() |>
  mutate(
    model = map(data, ~lm(body_mass_g ~ bill_length_mm, data = .x)),
    r2 = map_dbl(model, ~summary(.x)$r.squared)
  ) |>
  select(island, r2) |>
  mutate(r2 = round(r2, 3)) |>
  arrange(desc(r2))
```

---

## Section 7 : walk() - Effets de bord

### walk() pour les actions (print, save, etc.)

```{r demo-walk, exercise=TRUE}
# map() retourne des valeurs
penguins |> 
  split(~species) |> 
  map(~summarise(.x, n = n()))

# walk() pour les effets de bord (affichage, sauvegarde)
penguins |> 
  split(~species) |> 
  walk(~print(paste("Espèce:", unique(.x$species), "- N =", nrow(.x))))
```

### Exercice 7 : walk()

Utilisez `walk()` pour afficher un résumé de chaque île :

```{r ex7-walk, exercise=TRUE}
penguins |>
  split(~island) |>
  walk(~{
    cat("Île:", unique(.x$island), "\n")
    cat("Nombre:", nrow(.x), "\n")
    cat("---\n")
  })
```

```{r ex7-walk-solution}
penguins |>
  split(~island) |>
  walk(~{
    cat("=== Île:", unique(.x$island), "===\n")
    cat("Nombre d'observations:", nrow(.x), "\n")
    cat("Espèces présentes:", paste(unique(.x$species), collapse = ", "), "\n")
    cat("Masse moyenne:", round(mean(.x$body_mass_g, na.rm = TRUE), 0), "g\n\n")
  })
```

---

## Défi final

Créez une **analyse complète** avec nested data et map() :

1. Grouper par espèce
2. Pour chaque espèce :
   - Calculer n, moyenne et SD de la masse
   - Ajuster un modèle linéaire (masse ~ nageoires)
   - Créer un graphique
3. Extraire tous les résultats

```{r defi-final, exercise=TRUE, exercise.lines=20}
analyse_complete <- penguins |>
  group_by(_____) |>
  nest() |>
  mutate(
    # Stats descriptives
    stats = map(data, ~_____),
    
    # Modèle
    model = map(data, ~_____),
    r2 = map_dbl(model, ~_____),
    
    # Graphique
    plot = map2(_____, _____, ~_____)
  )

# Afficher résultats
analyse_complete |> select(_____)
```

```{r defi-final-solution}
analyse_complete <- penguins |>
  group_by(species) |>
  nest() |>
  mutate(
    # Stats descriptives
    stats = map(data, ~tibble(
      n = nrow(.x),
      masse_moy = mean(.x$body_mass_g, na.rm = TRUE),
      masse_sd = sd(.x$body_mass_g, na.rm = TRUE)
    )),
    
    # Modèle linéaire
    model = map(data, ~lm(body_mass_g ~ flipper_length_mm, data = .x)),
    r2 = map_dbl(model, ~summary(.x)$r.squared),
    
    # Graphique
    plot = map2(data, species, ~{
      ggplot(.x, aes(x = flipper_length_mm, y = body_mass_g)) +
        geom_point(alpha = 0.5, color = "steelblue") +
        geom_smooth(method = "lm", color = "red", se = TRUE) +
        labs(title = paste("Espèce:", .y),
             x = "Longueur nageoire (mm)",
             y = "Masse (g)") +
        theme_minimal()
    })
  )

# Résumé des résultats
analyse_complete |>
  select(species, stats, r2) |>
  unnest(stats) |>
  mutate(across(where(is.numeric), ~round(.x, 2)))

# Afficher un graphique
analyse_complete$plot[[1]]
```

---

## Récapitulatif

```{r cheatsheet, echo=TRUE, eval=FALSE}
# MAP - FAMILLE DE BASE
map(list, fonction)           # Retourne une liste
map_dbl(list, fonction)       # Retourne un vecteur double
map_chr(list, fonction)       # Retourne un vecteur character
map_int(list, fonction)       # Retourne un vecteur integer
map_lgl(list, fonction)       # Retourne un vecteur logical

# SYNTAXE AVEC FORMULE
map(list, ~mean(.x))          # .x = élément courant
map2(x, y, ~.x + .y)          # .x, .y = éléments de x et y
pmap(list, ~..1 + ..2)        # ..1, ..2 = premier, deuxième élément

# MAP MULTIPLES
map2(x, y, fonction)          # 2 inputs
pmap(list, fonction)          # n inputs

# NESTED DATA
group_by(var) |> nest()       # Créer données imbriquées
unnest(col)                   # Déimbriquer

# WALK - EFFETS DE BORD
walk(list, print)             # Pour affichage/sauvegarde
```

<div class="footer">
  <p>@ Cnam-Intechmer - 2025</p>
</div>
